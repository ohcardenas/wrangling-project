#### String parsing



url <- "https://en.wikipedia.org/w/index.php?title=Gun_violence_in_the_United_States_by_state&direction=prev&oldid=810166167"


murders_nodes <- read_html(url)%>%
               html_nodes("table")%>%
               html_table


murders_raw <- murders_nodes[[1]]%>%
               setNames(c("state", "population", "total", "murders"))
                        

head(murders_raw)


class(murders_raw$population)
class(murders_raw$total)




### Now letsstart with a really basic example to replace the commas in the 
### file that we have estracted 




### we create the function 
### we dont use {} to create this function 

comma <- function(x) any(str_detect(x, ","))


murders_raw %>% summarise_all(funs(comma))


test_1 <- str_replace_all(murders_raw$population, ",", "")

test_1 <- as.numeric(test_1)


test_1

#### Because this is such a commun issue on data science we have a function 
## that does all of this 

test_2 <- parse_number(murders_raw$population)

identical(test_1,test_2)

#### knowing that we have this easy option to do the same we can 



murders_new <- murders_raw %>% mutate_at(2:3, parse_number)


head(murders_new)

## COde to replace all separators 

murders_raw %>% mutate_at(2:3, funs(str_replace_all(., c("\\$|,"), ""))) %>% 
  mutate_at(2:3, as.numeric)



##### Let's get a little bit more complex

library(dslabs)

data("reported_heights")

class(reported_heights$height)



str(reported_heights)



x <-as.numeric(reported_heights$height)

head(x)


### we can check how many NA's we are creating by coercion 
sum(is.na(x))


reported_heights %>% mutate(new_height = as.numeric(height))%>%
   filter(is.na(new_height))%>%
   head(n = 10)


#### now we are going to apply some of the porbability theory 
### that we just saw 

alpha <- 1/10^6

qnorm(1-alpha/2 , 69.1, 2.9)


qnorm(alpha/2, 63.7, 2.7)



### we create a function that create an index of the as.numeric object 
### that we created 
### you can create a function that allows you to have an index 
### gives you only the problematic intakes



not_inches <- function(x, smallest = 50, tallest = 84){
  
  
  inches <- suppressWarnings(as.numeric(x))
  ind <- is.na(inches)| inches < 50 | inches > tallest
  ind
  

}



problems <- reported_heights %>%
            filter(not_inches(height))%>%
            .$height




length(problems)



problems %>% head(n=20) 



#### Now we need a pattern that is going to transform all of the 
### cases that we see in our 293 problematic cases 


### in the pattern we start with \\d\\s*'\\ which is indicating that it can
## be any digit followed by ' and after followed by a nother number 
## s*\\ whatever the number is 


pattern <-  "^\\d\\s*'\\s*\\d{1,2}\\.*\\d*'*\"*$"




#### come back to copy 




### Lets get back to somthing more basic to understand better 


library(tidyverse)


pattern <- ","


str_detect(murders_raw$total, pattern)

#### this would be the easiest pattern detect just a comma in bethwen 
### we can use parse_number in this kkind of comma problems remember that 




str_subset(reported_heights$height,"cm")

str_subset(reported_heights$height, ",")


### with the string subset we can get the pattern with cm in the height
###reported thats going to give us the items that are having cm 
## on heights 

### or any other patterns on the vector 


## we are going to create two parts of a vector one that is respondinto to 
## our detect argumentns and one that doesnt 


yes <- c("180 cm", "70 inches")
no <- c ("180", "70''")


s <- c(yes, no )



str_detect(s, "cm")|str_detect(s, "inches")

### As we can see we are detecting the entries of the vector that we added 
## for yes 

## we can do the same by just adding the | or statement inside the 
# string detect

str_detect(s, "cm|inches")



### We can use str_view



str_view(s, pattern)

## pattern descriptions 
### tecniclly any string is a regex 
## main thing that diferentiates regex language from standat is that 
## we have different characters that have a meaning | this means or 
## /d means any digits in r we have to scape the backlash to represent 
## the digits so we need to use //d


yes <- c("5","6","5'10", "5 feet", "4'11")
no <- c(",", ".", "Five", "six") 

s <- c(yes, no)
pattern <- "\\d"


str_detect(s, pattern)


## We can see that we are detecting only the elements that have digits in 
## in this case what we have on yes 


## NOw lets try to understand more coplex patterns like this pattern


pattern <- "^[4-7]'\\d{1,2}\"$"

## we start the pattern ^
## one digit can be 456 or 7 
## followed by the ' feet symbol
## \\d{1,2} this tells us is one or two digits 
## \" and this one tells us its having the inches symbol 
## $ end of the string


### Another usefull expretion is \s



problems <- reported_heights %>%
  filter(not_inches(height))%>%
  .$height



## we can see that 


identical("Hi", "Hi ")

## Is not the same ecause of the space that is after the second 
## hi 

pattern_2 <- "^[4-7]'\\s\\d{1,2}\"$"


## remember that str_subset is going to give only the entries that match 
## your pattern 


str_subset(problems, pattern_2)


## now is going to recognise the patterns that have a space after the ' inches 
## symbol 

## character classes are used to define a series of characters that can be maatch 
## as we did before 

str_view(s, "[56]")
 
## only matches the ones that have a 5 or a 6 so [4-7] would match 456 or 7 
## note that in regex everythin gis a character there are not numbers so 4 is the
## character 4 and is we [1-20] we are talking about 1,2 and the charater 0 


## for the same reason we can define the range [a-z] and thats all lower case letters
## if we would like all the letters we would [a-zA-Z]


## as we jjust saw ^ beginig of a string and $ end of a string respectively 
## ^\\d$ so this pattern is all the digits


## lets test a pattern that includes all of this quantifiers 


pattern <- "^[4-7]'\\d{1,2}\"$"


yes <- c("5'7\"", "6'2\"",  "5'12\"")
no <- c("6,2\"", "6.2\"","I am 5'11\"", "3'2\"", "64")

s <- c(yes,no)

str_detect(yes, pattern)
str_detect(no, pattern)


## if we apply our rule to aour problems object we see that our pattern doesnt include as many 

pattern <- "^[4-7]'\\d{1,2}\"$"


sum(str_detect(problems, pattern))

## only applies to 14 of the problematic entries 

## to see why our succes rate is not as hight we can se some examples that show why we dont have 
## covert that many entries 

problems[c(2,10,11,12,15)]%>% str_view(pattern)



### you see in this sample other different problems that we can solve with other 
## tools in our stringr package 


## lets see how many are expressed with the word inches 


str_subset(problems, "inches")


## lets see how many are expresed with a double feet symbol 


str_subset(problems, "''")


### one of the problems being that you some people uploaded their info with '' two
## feet symbol we can include those by not puting in the pattern the ' after the 
## feet 

pattern <- "^[4-7]'\\d{1,2}$"


### Now before applying the pattern we are going to replace some of the common 
## ways of expressing inches and feet to fit our pattern 



problems %>%
            str_replace("feet|ft|foot", "'")%>%    # remove all feet ft foot
            str_replace("inches|in|''|\"", "")%>% # remove all inches|in|''|\""
            str_detect(pattern)%>%
            sum


### as we said "Hi" is not the same as "Hi " for r 


identical("Hi", "Hi ")


### we are going to use the \\s which means space for R to create a better pattern to 
## to have a bigger succes rate 


pattern_2 <- "^[4-7]'\\s\\d{1,2}\"$"

str_subset(problems, pattern_2)


### We dont have a lot of entries that adapt to that regex because we are just 
## looking for the ones that are 

## we are going to see ho can you use * , ? , and + 


yes <- c("AB", "A1B", "A11B", "A111B", "A1111B")
no <- c("A2B", "A21B")

str_detect(yes, "A1*B")

### this is going to detect all of the A*B that dont have a 1 have a 1 inbetween 
## or have multiple ones in between 


str_detect(no, "A1*B")

## We can see how the no example doesn't have any of those examples 




yes <- c("AB", "A1B", "A11B", "A111B", "A1111B")

### in this case they define the string inside and outside 

### inside to define the column in the data frame and outside 

data.frame(string = c("AB", "A1B", "A11B", "A111B", "A1111B"),
            none_or_more = str_detect(yes , "A1*B"),
            none_or_once = str_detect(yes,  "A1?B"),
            once_or_more = str_detect(yes,  "A1+B"))
            



##Now lets understand how patterns with groups or without groups are going to work


pattern_without_group <- "^[4-7],\\d*$"


pattern_with_group <- "^([4-7]),(\\d*)$"


###  Let's create the examples 


yes <- c("5,9", "5,11", "6,", "6,1")
no <- c("5'9", ",", "2,8", "6.1.1")



s <- c(yes, no )


str_detect(s, pattern_without_group)




str_detect(s, pattern_with_group)

str_subset(s, pattern_with_group)



### Let's introduce 2 new functions 


str_extract(s, pattern_with_group)

## YOu can see that the str_match get's each of the matches for the groups 

str_match(s, pattern_with_group)



### Now we are going to replace the matches by mentioning the changes that we 
## want to do per group


pattern_with_group <- "^([4-7]),(\\d*)$"


yes <- c("5,9", "5,11", "6,", "6,1")
no <- c("5'9", ",", "2,8", "6.1.1")

s <- c(yes,no )

str_replace(s, pattern_with_group, "\\1',\\2")


### We want to improove that pattern by adding all of the osible separator that 
## we see in our sample 

pattern <- "^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$"


str_subset(problems, pattern)%>% head



str_subset(problems, pattern) %>%
  str_replace(pattern , "\\1'\\2")%>% head



as.numeric(reported_heights$height)


reported_heights$height


not_inches_or_cm <- function(x, smallest = 50, tallest = 84){
      inches <- suppressWarnings(as.numeric(x))
      ind <- !is.na(inches) &
            ((inches >= smallest & inches <= tallest ) |
      (inches/2.54 >= smallest & inches/2.54 >= tallest))
  !ind
}


problems <-  reported_heights%>%
             filter(not_inches_or_cm(height))%>%
            .$height


length(problems)


problems%>% head(n=30)

str_subset(problems, "feet")

converted <- problems %>% 
  str_replace("feet|foot|ft", "'")%>%
  str_replace("inches|in|''|\"", "")%>%
  str_replace("^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$","\\1'\\2")





pattern_guide <- "^[4-7]\\s*'\\s*\\d{1,2}$"

index <- str_detect(converted, pattern_guide)


mean(index)


converted[!index]





### Assesment 




s <- c("70","5 ft","4'11","",".","Six feet")


pattern <- "\\d|ft"


str_view_all(s, pattern)


animals <- c("cat", "puppy", "Moose", "MONKEY")



str_detect(animals, "[A-Z]$")

### some how by adding the symbol $ at the end is implying that all of the letters
## have to be capital 



pattern <- "[a-z]{4,5}"


str_detect(animals, pattern)



animals <- c("moose", "monkey", "meerkat", "mountain lion")

pattern <- "mo*"

str_detect(animals, pattern)

pattern <- "mo?"


str_detect(animals, pattern)


### remember that ? would be none of 1 


schools <- c("U. Kentucky","Univ New Hampshire","Univ. of Massachusetts"
             ,"University Georgia","U California","California State University")         


pattern <- "^Univ\\.?|^U\\.?\\s"

### in this case we are saying U followed wy a . or not followed by a space 



str_detect(schools, pattern) 
  


schools %>% 
  str_replace("^Univ\\.?\\s|^U\\.?\\s", "University ")%>%
  str_replace("^University of |^University ", "University of ")




new_problems <- c("5.3", "5,5", "6 1", "5 .11", "5, 12")

pattern <- "^([4-7])[.\\,](\\d*)$"

### Against the code that we used on the excercise in here we dont specify the 
## spaces before or after the comma and the dot and we dont specify either the 
## space in the [] separators 

str_detect(new_problems,pattern)



str_replace(new_problems, pattern, "\\1'\\2")


#### We already have used the separate function in the past lets use it again 
## and introduce extract wich works similarly but it allow's us to use regex 


s <- c("5'10", "6'1")

s

tab <- data.frame(x=s)

tab


tab %>% separate(x, c("feet", "inches"), sep = "'")

### now we are going to use extract 


tab %>% extract(x, c("feet", "inches"), regex = "(\\d)'(\\d{1,2})")
        
        
### Second Example 


s <- c("5'10", "6'1\"","5'8inches")


tab <- data.frame(x = s)


tab %>% separate(x, c("feed", "inches"), sep = "'", fill = "right")


tab_new <- tab %>% extract(x, c("feed", "inches"), regex = "(\\d)'(\\d{1,2})")


tab_new$feed %>% str_replace("(\\d)", "\\1'")

tab_new




#### Let's understand a little bit better the ^ and the $ symbols 

## when we use this symbols on a pattern what we are sayin is that it has to 
## start with anything after ^??? and in the case of $ means it has to end with 
## ???$ whatever before the $ 


yes <- c("5", "6", "5")
no <- c("5'", "5''", "5'4")


s <- c(yes,no)


str_replace(s, "^([4-7])$", "\\1'0")


## if we add that 0 our pattern will match 

## how to adapt that code so it recognises the no cases 



str_replace(s, "^([4-7])'*$", "\\1'0")

### leave the ' outside the group () BECAUSE IF NOT IS JUST ADDING ' 
## without replacing the existing one 

## Lets create a pattern that correctly identifies the next example  of yes 


yes <- c("1,7", "1, 8", "2, " )
no <- c("5,8", "5,3,2", "1.7")
s <- c(yes, no)


pattern <- "^([12])\\s*,\\s*(\\d*)$"

str_detect(s, pattern)

## we will replace the commas by a dot in this case 


str_replace(s, pattern, "\\1.\\2")

## new fi=unction introduced 


s <- c("5 '", "9 ")


str_trim(s)

### lets apply everything that we learned 




not_inches_or_cm <- function(x, smallest = 50, tallest = 84){
  inches <- suppressWarnings(as.numeric(x))
  ind <- !is.na(inches) &
    ((inches >= smallest & inches <= tallest ) |
       (inches/2.54 >= smallest & inches/2.54 >= tallest))
  !ind
}


convert_format <- function(s){
  s %>%
    str_replace("feet|foot|ft", "'") %>% #convert feet symbols to '
    str_replace_all("inches|in|''|\"|cm|and", "") %>%  #remove inches and other symbols
    str_replace("^([4-7])\\s*[,\\.\\s+]\\s*(\\d*)$", "\\1'\\2") %>% #change x.y, x,y x y
    str_replace("^([56])'?$", "\\1'0") %>% #add 0 when to 5 or 6
    str_replace("^([12])\\s*,\\s*(\\d*)$", "\\1\\.\\2") %>% #change european decimal
    str_trim() #remove extra space
}




words_to_numbers <- function(s){
  str_to_lower(s) %>%  
    str_replace_all("zero", "0") %>%
    str_replace_all("one", "1") %>%
    str_replace_all("two", "2") %>%
    str_replace_all("three", "3") %>%
    str_replace_all("four", "4") %>%
    str_replace_all("five", "5") %>%
    str_replace_all("six", "6") %>%
    str_replace_all("seven", "7") %>%
    str_replace_all("eight", "8") %>%
    str_replace_all("nine", "9") %>%
    str_replace_all("ten", "10") %>%
    str_replace_all("eleven", "11")
}


### The not inches or cm in here is really important because is parsing the 
## height object to not have nas being and being in a numeric format


problems <- reported_heights %>%
  filter(not_inches(height))%>%
  .$height


### To make this a string we have to parse it first and run the problems function
## that we created 




  
  


converted <- problems %>% words_to_numbers %>% convert_format



converted

remaining_problems <- converted[not_inches_or_cm(converted)]


remaining_problems



pattern <- "^([4-7])\\s*'\\s*(\\d+)\\.?\\d*$"



index <- str_detect(remaining_problems, pattern)

str_subset(remaining_problems,pattern)

str_replace(remaining_problems,pattern, "\\1'\\2")

remaining_problems_2 <-remaining_problems[!index]





#### Lets split with the stringr package 


murders_raw <- system.file("extdata/murders.csv", package = "dslabs")


lines <- readLines(murders_raw)


lines%>% head()


x <- str_split(lines, ",")


head(x)

## we are going to name the first line as columns 

col_names <- x[[1]]

col_names 
x <- x[-1]

head(x)



## With map you can get a function applyed to all of the elements on your list

library(purrr)


map(x, function(y) y[1])%>% head


## we are just getting all of our elements for our first row 


### Because we just want to get the first element we dont want to aply anything 
## else to the element on the list map is already prebuilt to do that if you just 


map(x, 1) %>% head 

help("parse_guess")


dat <- data.frame(parse_guess(map_chr(x,1)),
                  parse_guess(map_chr(x, 2)),
                  parse_guess(map_chr(x,3)),
                  parse_guess(map_chr(x,4)),
                  parse_guess(map_chr(x,5)))%>%

setNames(col_names)



dat %>% head  

### Lets do the same a little bit more efficiently 
### e voila after transposing the list and apply the map function with parse_guess

dat <- x %>%
       transpose()%>%
       map(~parse_guess(unlist(.)))%>%
       setNames(col_names)%>%
       as.data.frame()
               
help("transpose")  

dat                


###  we can do the same by using the str_splt with a new argument sumplify = true 


x <- str_split(lines, ",", simplify = TRUE)
x


col_names <- x[1,]

col_names
x <- x[-1, ]

x


x %>% as_tibble()%>%
      setNames(col_names)%>%
      mutate_all(parse_guess)
      

### If we wanted as a data frame

as.data.frame(x)%>% setNames(col_names)






## Extracting a Pdf info 


library(dslabs)


data("research_funding_rates")


research_funding_rates


library("pdftools")

temp_file <- tempfile()

url <- "https://www.pnas.org/action/downloadSupplement?doi=10.1073%2Fpnas.1510159112&file=pnas.201510159SI.pdf"

download.file(url, temp_file)

txt <- pdf_text(temp_file)

file.remove(temp_file)

txt
print(txt)



raw_data_research_funding_rates <- txt[2]

### Ignore this code and work with the data in the dslabs package


data("raw_data_research_funding_rates")

raw_data_research_funding_rates %>% head


### we see that it is a long string. Each line on the page, 
##including the table rows, is separated by the symbol for newline: \n.
                 

tab  <- str_split(raw_data_research_funding_rates, "\n")


tab %>% head

### Because we started with just one element on this txt we have just one element 
## so we have to call it 



tab <- tab[[1]]

tab %>% head


col_names_1 <- tab[3]

col_names_1


col_names_2 <- tab[4]


col_names_2

print(col_names_2)

### when we apply the ",\\s." removes the % and the ns for some reason 
### because we dont specify and end by putting $ at the end its deleting anything
### that follows the comma look at the dot following the space 


col_names_1 <- col_names_1 %>%
               str_trim()%>%
               str_replace_all(",\\s.", "")%>%
               str_split("\\s{2,}", simplify = TRUE)

col_names_1


### We want to split only when there are 2 or more spaces to avoid splitting 
###Success rates. So we use the regex \\s{2,}


### lets work on our secon column of names 
col_names_2

col_names_2 <- col_names_2 %>%
  str_trim() %>%
  str_split("\\s+", simplify = TRUE)


col_names_2

### Introducing str_c to join multiple strings 
### this function gives you the option to insert a sep between input vectors 



help("str_c")
help("rep")


rep(1:4, 2)

rep(1:4, each = 2)

### rep repeats the elements of a string or vector if you use the each argument 
## the repeated arguments are one after the other 

dim(col_names_2)


### the [-1] in col_names is to ignore the first row the discipline to get 
## aplication_total aplication_men aplication_woman and the same with the 
## other elements of the col_names_1 awards and success 


tmp_names <- str_c(rep(col_names_1, each = 3), col_names_2[-1], sep = "_")

tmp_names

### we recover the discipline column, we convert all the cases to lower case 
## and we replace all the spaces with underscore

the_names <- c(col_names_2[1], tmp_names)%>%
             str_to_lower()%>%
             str_replace_all("\\s", "_")



the_names

print(tab)



### we want to get our information now and that's going to from the row 6 to 
## our column 14 
## lets take the spaces with str_trim
### the simplify = TRUE organises the table 
## we set the names of the columns 

new_research_funding_rates <- tab[6:14] %>%
        str_trim %>%
        str_split("\\s{2,}", simplify = TRUE)%>%
        data.frame(stringsAsFactors = FALSE)%>%
        setNames(the_names)%>%
        mutate_at(-1, parse_number)


new_research_funding_rates%>% head



###We want to split only when there are 2 or more spaces to avoid splitting 
## Success rates. So we use the regex \\s{2,}


### Assesment str processing


day <- c("Monday","Tuesday")

staff <- c("Mandy, Chris and Laura","Steve, Ruth and Frank")

example <- data.frame(day,staff)


str_split(example$staff, ",|and")


### how to create a table from the that makes more sense 
### important


x <- example %>% mutate(staff = str_split(staff, ", |and "))%>%
     unnest(cols = c(staff))
     
     
     
x


help("seq")

x <- seq(1.95, 1.95999 , by = 0.0001)



str_detect(x, "^1\\d*$")


str_detect(x,"^1\\d+\\.\\d?$")

str_detect(x, "[1-9]*\\.5")



#### Assesment part 2 string processing 

library(rvest)
library(tidyverse)
library(stringr)

url <- "https://en.wikipedia.org/w/index.php?title=Opinion_polling_for_the_United_Kingdom_European_Union_membership_referendum&oldid=896735054"

h <- read_html(url)

nodes <- html_nodes(h, "table")


table_1 <- nodes[[6]] %>% html_table(fill = TRUE)


table_1 %>% head


c("dates", "remain", "leave", "undecided", "lead", "samplesize", "pollster", "poll_type", "notes")

table_2 <- table_1 %>% setNames(c("dates", "remain", "leave", "undecided", "lead", "samplesize", "pollster", "poll_type", "notes"))


table_2 <- table_2[-1,]





#### Lets detect problematic cases on the remain column



str_detect(table_2$remain,"%$")

## we check for the specific problematic entries

table_2$remain[81]


### Lets create a function that will allow us to filter the problemaic entries



percentage <- function(x){
  
  
  index <- str_detect(x,"%$")
  
  
  }





table_2 <- table_2 %>% filter(percentage(remain))



nrow(table_2)


## Lets modify the remain column so is going to be easier to operate 

### somehow the parse number function does work in this case when using the 
## parse number it automatically changes the class of the column to a numeric 

x <- parse_number(table_2$remain)/100 

class(x)


### this codes wont work in this case the class remains character so it wont 
## operate


str_remove(table_2$remain, "%")/100


### Let's modify our undecided column the diferent N/A that we are getting 
## come from the remain and leave adding up to 100 percent meaning that the 
## undecided should be 0



table_2 <- table_2 %>% mutate(remain = as.numeric(str_replace(table_2$remain,"%", ""))/100)



table_2 <- table_2 %>% mutate(undecided = str_replace(table_2$undecided, "N/A", "0"))



table_2

pattern <- "\\d+\\s[a-zA-z]+"
  
  
print(table_2$dates %>% head(n = 30))  
  

temp <- str_extract_all(table_2$dates, "\\d+\\s[a-zA-z]+" )

end_date <- sapply(temp, function(x) x[length(x)])

end_date


temp                       


                       











  